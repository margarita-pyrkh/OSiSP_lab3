к 3 лабе по осиспу:
pid везде выводить
!распараллеливание!
то есть создавать процессы
пример
main()
{

	// open() - если тут откроем файл, то он будет открыт в двух процессах
	p = fork(); // это А
	1)преимущества, сбой одного про-са не приводит к заершению работы другого
	посмотреть кол-во рабочих про-сов ps -x

}

а) повышение быстродействия
б) повышение надежности ()

примеры практические


в лабе создаем какой-то пулл процессов, т.е. какие-то n процессов.
Если какой-то из процов завершился, то после своего завершения он создает новыЕ, до тех пор, пока 

каждый процесс попадает в псевдострутуру /proc/pid
этот каталог находится в памяти, он очень быстро изменяется
по сути это структура яда=ра, которая отражает его ссостяние: какие про-сы в кольцевом списке и т.п.
собсна, юзанем команду ps, которая дает то же самое


сначала проверять, а потом в соответсвующей ветви выполнять

отлаживать программы такие трудно

прередаем инфу с помощью файла

для того чтобы про-сы правильно работали и завершались
сначала должен завершиться дочерний, а потом родительский
но реально это узнать нельзя, только с помощью фу-ции wait();
проверяет, завершился ли процесс

если он завершился раньше, то нужно оставить его в кольцевом списке как проц-зомби

потому для каждого потомка нужно использовать wait
а получить пид можно с помощью getpid();

4 fork'a  подряд - 16 процессов


у каждого про-са имеется свой приоритет, который как бы можно изменить с помощью команды найс(?), но лучше этого не делать